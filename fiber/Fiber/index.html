<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fiber (fiber.Fiber)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">fiber</a> &#x00BB; Fiber</nav><h1>Module <code>Fiber</code></h1><p>Fast native fibers for OCaml.</p><p>Fibers are implemented by tying together <a href="http://software.schmorp.de/pkg/libcoro.html">libcoro</a> and OCaml's GC hooks. This design allows <em>allocation free</em> context switches with decent performance. For example, i7-8750H running Linux can perform about 13.7M fiber context switches per second. If you want to measure it by yourself just run <code>make all bench</code> from the source directory.</p><nav class="toc"><ul><li><a href="#basic-api">Basic API</a></li><li><a href="#event-loop">Event loop</a></li><li><a href="#synchronisation">Synchronisation</a></li></ul></nav></header><section><header><h2 id="basic-api"><a href="#basic-api" class="anchor"></a>Basic API</h2><p>The basic API allows creation of a fiber and switching back and forth. It follows closely <a href="https://www.lua.org/pil/9.1.html">Lua coroutines</a>.</p><p>To give some idea of how it works, here is an example of printing numbers from 1 to 10 in a fiber way:</p><pre><code class="ml">let fb = Fiber.create (fun () -&gt;
	     for i = 1 to 10 do
	       print_int i;
	       print_newline ();
	       Fiber.yield ()
	     done) ()

let _ =
  for j = 1 to 10 do
    Fiber.resume fb
  done</code></pre><p>More examples available in the <code>examples</code> directory.</p></header><dl><dt class="spec type" id="type-fiber"><a href="#type-fiber" class="anchor"></a><code><span class="keyword">type </span>'a fiber</code></dt><dd><p>a fiber type.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val </span>create : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-fiber">fiber</a></code></dt><dd><p><code>create f arg</code> creates a fiber.</p><p>A fiber can be in one of the following states: <code>sleeping</code>, <code>running</code> or <code>dead</code>. A fiber will initially be in state <code>sleeping</code>. Upon <a href="index.html#val-resume"><code>resume</code></a>, the fiber will execute <code>f arg</code>. When <code>f</code> returns the fiber enters state <code>dead</code>. return value of <code>f</code> can be obtained by calling <a href="index.html#val-join"><code>join</code></a>.</p><p>Current implementation allocates 112 pages of stack and 16 pages of guard zone. Graceful stack overflow detection is not (yet) implemented and stack overflow will result in segmentation violation.</p><p>Fiber context creation is a relatively expensive process and therefore library caches unused contexts of dead fibers. The cache size is unbound, be careful when creating a lot of short living fibers.</p><p>Exception behavior is similar to the vanilla OCaml. You can <code>raise</code> exception inside a fiber and catch it with a <code>try ... with ...</code>. Uncaught exception in a fiber will terminate the whole program.</p></dd></dl><dl><dt class="spec value" id="val-yield"><a href="#val-yield" class="anchor"></a><code><span class="keyword">val </span>yield : unit <span>&#45;&gt;</span> unit</code></dt><dd><p><code>yield</code> yields control to the caller (the fiber which issued <a href="index.html#val-resume"><code>resume</code></a>). Consequently, it is an error to call <code>yield</code> from initial context, since there is no caller.</p></dd></dl><dl><dt class="spec value" id="val-resume"><a href="#val-resume" class="anchor"></a><code><span class="keyword">val </span>resume : <span class="type-var">'a</span> <a href="index.html#type-fiber">fiber</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>resume fb</code> resumes the fiber <code>fb</code>, that is: transfer execution context to it. Trying to resume dead fiber will raise <code>Invalid_argument &quot;Fiber.resume&quot;</code>.</p></dd></dl></section><section><header><h2 id="event-loop"><a href="#event-loop" class="anchor"></a>Event loop</h2><p>Integration with <a href="http://software.schmorp.de/pkg/libev.html">libev</a> event loop.</p></header><dl><dt class="spec value" id="val-run"><a href="#val-run" class="anchor"></a><code><span class="keyword">val </span>run : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p><code>run f arg</code> starts the event loop and executes <code>f arg</code> inside a newly created fiber. Returns <code>None</code> if <a href="index.html#val-break"><code>break</code></a> is called during execution of <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-break"><a href="#val-break" class="anchor"></a><code><span class="keyword">val </span>break : unit <span>&#45;&gt;</span> unit</code></dt><dd><p><code>break</code> stops event loop and exits from <a href="index.html#val-run"><code>run</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-wake"><a href="#val-wake" class="anchor"></a><code><span class="keyword">val </span>wake : <span class="type-var">'a</span> <a href="index.html#type-fiber">fiber</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>wake fb</code> register a wakeup for a fiber <code>fb</code>. A fiber <code>fb</code> will be resumed in the next iteration of the event loop.</p></dd></dl><dl><dt class="spec value" id="val-cancel_wake"><a href="#val-cancel_wake" class="anchor"></a><code><span class="keyword">val </span>cancel_wake : <span class="type-var">'a</span> <a href="index.html#type-fiber">fiber</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>cancel_wake fb</code> cancels pending wakeup for <code>fb</code>.</p></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val </span>join : <span class="type-var">'a</span> <a href="index.html#type-fiber">fiber</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>join fb</code> suspends the current fiber until <code>fb</code> is dead and returns the return value of it. It is permitted to call <code>join fb</code> several times.</p></dd></dl><dl><dt class="spec type" id="type-event"><a href="#type-event" class="anchor"></a><code><span class="keyword">type </span>event</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-event.READ" class="anchored"><td class="def constructor"><a href="#type-event.READ" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">READ</span></code></td></tr><tr id="type-event.WRITE" class="anchored"><td class="def constructor"><a href="#type-event.WRITE" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">WRITE</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-wait_io_ready"><a href="#val-wait_io_ready" class="anchor"></a><code><span class="keyword">val </span>wait_io_ready : Unix.file_descr <span>&#45;&gt;</span> <a href="index.html#type-event">event</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>wait_io_ready fd ev</code> suspends the current fiber until reading or writing from file descriptor <code>fd</code> can be performed without blocking.</p><p>Please note, that the library itself doesn't put file descriptor into a nonblocking mode. Therefore, it's advisable to either put file descriptor into nonblocking mode before calling <code>read(2)</code> and <code>write(2)</code>or use <code>send(2)</code>and <code>recv(2)</code> with corresponding <code>flags</code>.</p></dd></dl><dl><dt class="spec value" id="val-sleep"><a href="#val-sleep" class="anchor"></a><code><span class="keyword">val </span>sleep : float <span>&#45;&gt;</span> unit</code></dt><dd><p><code>sleep s</code> suspends the current fiber for <code>s</code> seconds.</p></dd></dl></section><section><header><h2 id="synchronisation"><a href="#synchronisation" class="anchor"></a>Synchronisation</h2></header><div class="spec module" id="module-Mutex"><a href="#module-Mutex" class="anchor"></a><code><span class="keyword">module </span><a href="Mutex/index.html">Mutex</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Condition"><a href="#module-Condition" class="anchor"></a><code><span class="keyword">module </span><a href="Condition/index.html">Condition</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-MVar"><a href="#module-MVar" class="anchor"></a><code><span class="keyword">module </span><a href="MVar/index.html">MVar</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>